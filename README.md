# 난해한 PROBIE 언어, 0.2판 정의

# 1. 개요
- PROBIE 언어는 2차원 `필드`로 작성된 코드 위를 지속적으로 이동하는 `프로브`에 의해 연산이 수행되는 언어입니다. 코드 공간과 메모리 공간이 분리되어 있지 않으며, 코드 자체가 실시간으로 수정되면서 작동한다는 점을 특징으로 합니다.

# 2. 필드의 정의
- 필드는 코드 자체를 의미하며, 한 줄의 너비가 일정한 텍스트 형태로 작성됩니다. 필드 위의 각 문자는 `셀`이라고 부릅니다. 인터프리터는 코드 첫 줄의 너비를 기준으로 필드의 너비를 판단하며, 이후 프로브나 커서가 값을 읽어들이거나 쓰려고 하지만 그 위치에 셀이 존재하지 않을 때 오류를 출력합니다.
- 인터프리터가 동작되는 동안 필드 내의 셀들은 프로브에 의해 실시간으로 수정되며 데이터 저장과 연산을 수행합니다. 셀의 위치는 `[Y,X]`와 같이 표현되며, 이는 필드를 2차원 배열로 볼 때 `Y`행 `X`열의 문자를 의미합니다. 코드의 맨 첫 번째 문자의 위치는 `[0,0]`입니다.

# 3. 커서와 프로브의 정의
- 필드 위에는 항상 `MEM 커서`와 `프로브`가 존재하며, `프로브`는 `READ 포인터`와 `WRITE 포인터`로 이루어져 있습니다.
## 3.1. `MEM` 커서
- `MEM` 커서는 프로브의 명령이 있을 때에만 이동하며, 값을 필드에 저장하거나 불러오는 역할을 합니다. `MEM` 커서는 프로그램이 시작할 때 `[0,0]` 위치에 있습니다.
## 3.2. 프로브
- 프로브는 항상 동적이며, 한 번에 일정 간격씩 인접한 셀로 이동하며 동작을 수행합니다. 프로브의 이동 간격이 0이 되는 것은 프로그램이 종료되는 것으로 취급됩니다. 프로브는 명령을 읽어들이는 `READ` 포인터와 명령을 수행하는 `WRITE` 포인터로 이루어져 있으며, 자체적으로 문자를 하나 저장할 수 있습니다. (값이 어떤 형태로 저장되는지에 대해서는 4. 문자와 값을 참조하십시오)
### 3.2.1. `READ` 포인터
- `READ` 포인터는 매번 일정 간격으로 이동하면서 명령을 읽어들이며, 프로브의 위치는 `READ` 포인터의 위치로 정의됩니다. `READ` 포인터는 프로그램 시작 시 `[0,0]`에 위치하며, 오른쪽으로 1칸씩 이동하기 시작합니다.
### 3.2.2. `WRITE` 포인터
- `WRITE` 포인터는 `READ` 포인터가 읽어들이는 명령을 수행하는 역할을 하며, `WRITE` 포인터의 위치는 `READ` 포인터에 상대적으로 정의됩니다. `WRITE` 포인터의 위치는 프로그램 시작 시 `READ` 포인터에 대해 `[0,0]`입니다.

# 4. 문자와 값
- 프로브와 셀에 저장되는 모든 값은 문자의 형태로 저장됩니다. 예를 들어, 셀에서 `0`에 `0`을 더하는 연산을 수행할 경우 `B`가 됩니다.
## 4.1. 값의 크기 
- ASCII 코드표에 존재하는 문자는 해당 코드와 같은 크기의 값을 가집니다.
- ASCII 코드표에 존재하지 않는 문자는 모두 0의 값을 가집니다.
- 단, ASCII 코드표에서 0번부터 31번까지, 그리고 127번은 제어 문자로 입출력이 어렵기 때문에, 대신 다음의 문자들이 값을 가집니다.
  - `○` : 0 (연산 결과가 0일 경우 기본적으로 이 문자가 들어갑니다.)
  - `①` - `⑮` : 1 - 15
  - `◎` : 16
  - `⑴` - `⒂` : 17 - 31
  - `●` : 127
## 4.2. 특수한 문자
- 일부 문자들은 두 셀을 차지합니다. 프로브는 읽기 활동 도중 '\' 문자가 나오면 다음 문자까지 읽어 저장하게 됩니다. 이들은 보통 `P`나 `I` 상태의 프로브가 개행 등의 작업을 처리하는 데에 사용됩니다.
- 이들 문자는 연산에서 모두 0의 값을 가지며, 읽는 방향에 따라 다르게 판독될 수 있음에 주의해 주세요.
- `\0` : 문자열의 끝을 나타냅니다.
- `\n` : 개행 연산을 나타냅니다.
- `\t` : 탭을 나타냅니다.
- `\\` : `\` 문자를 나타냅니다.
- `\` 이후에 이상의 예시 이외의 기타 문자가 판독될 시 프로브는 `\` 문자를 덮어쓰기합니다.
# 5. 커맨드
- 다음의 커맨드들은 `READ` 포인터에 의해 판독되는 즉시 유효합니다. 따라서, `READ` 포인터와 `WRITE` 포인터의 상대적 위치는 되도록 `[0,0]`이 아닌 것이 좋습니다. (`READ` 포인터와 `WRITE` 포인터가 같은 위치에 있다면 `P` 명령은 항상 자기 자신을 출력할 것이며, `I` 명령은 항상 덮어쓰기가 될 것이기 때문입니다.) 
- 커맨드는 크게 프로브가 한 번 특정한 동작을 수행하게 하는 휘발성 커맨드, 프로브와 커서의 이동에 관여하는 이동 커맨드와 프로브가 지속적으로 특정 동작을 수행하게 하는 비휘발성 커맨드로 나뉘며, 이들은 이동 커맨드 → 비휘발성 커맨드 → 휘발성 커맨드 순의 우선 순위를 가지고 있습니다.
## 5.1. 휘발성 커맨드
### 5.1.1. 조건문
- 조건문들은 모두 프로브를 1칸 이동시키는 역할을 합니다. 비교의 결과에 따라 이동의 방향이 결정되며, 이는 프로브 자체의 지속적인 이동 간격과 방향에는 영항을 미치지 않습니다.
- `{` : 현 위치에서 1셀 위와 1셀 아래에 있는 값들을 비교합니다. 위쪽 값이 크다면 왼쪽으로, 아니면 오른쪽으로 프로브를 이동시킵니다.
- `}` : 현 위치에서 1셀 위와 1셀 아래에 있는 값들을 비교합니다. 위쪽 값이 크다면 오른쪽으로, 아니면 왼쪽으로 프로브를 이동시킵니다.
- `∧` : 현 위치에서 1셀 왼쪽과 1셀 오른쪽에 있는 값들을 비교합니다. 왼쪽 값이 크다면 위쪽으로, 아니면 아래쪽으로 프로브를 이동시킵니다.
- `∨` : 현 위치에서 1셀 왼쪽과 1셀 오른쪽에 있는 값들을 비교합니다. 왼쪽 값이 크다면 아래쪽으로, 아니면 위쪽으로 프로브를 이동시킵니다.
- `↔` : 프로브에 저장된 값과 `WRITE` 포인터 위치의 값을 비교합니다. 프로브에 저장된 값이 크다면 왼쪽으로, 아니면 오른쪽으로 프로브를 이동시킵니다.
- `↕` : 프로브에 저장된 값과 `WRITE` 포인터 위치의 값을 비교합니다. 프로브에 저장된 값이 크다면 위쪽으로, 아니면 아래쪽으로 프로브를 이동시킵니다.
### 5.1.2. 연산자
- 연산을 수행할 때에는 각 셀과 프로브에 저장될 수 있는 값의 크기는 0에서 127까지이며, 이를 넘는 범위의 값은 128로 나눈 나머지만 저장된다는 점을 유의하시기 바랍니다.
#### 5.1.2.1. `WRITE` 포인터 위치의 값 변경
- `+` : `WRITE` 포인터 위치의 셀에 프로브에 저장된 값을 더합니다.
- `-` : `WRITE` 포인터 위치의 셀에서 프로브에 저장된 값을 뺍니다.
- `×` : `WRITE` 포인터 위치의 셀에 프로브에 저장된 값을 곱합니다.
- `÷` : `WRITE` 포인터 위치의 셀에서 프로브에 저장된 값을 나눕니다.
- `%` : `WRITE` 포인터 위치의 셀을 프로브에 저장된 값으로 나눈 나머지를 구합니다.
#### 5.1.2.2. 프로브에 저장된 값 변경
- `A` : 프로브에 저장된 값에 `WRITE` 포인터 위치의 값을 더합니다.
- `D` : 프로브에 저장된 값에서 `WRITE` 포인터 위치의 값을 뺍니다.
- `M` : 프로브에 저장된 값에 `WRITE` 포인터 위치의 값을 곱합니다.
- `d` : 프로브에 저장된 값에서 `WRITE` 포인터 위치의 값을 나눕니다.
- `m` : 프로브에 저장된 값을 `WRITE` 포인터 위치의 값으로 나눈 나머지를 구합니다.
### 5.1.3. `MEM` 상호 작용
- `MEM` 커서 위치에 값을 저장하고 불러오는 데에 사용하는 연산들은 다음과 같습니다.
- `[` : 프로브에 저장된 값을 `MEM` 커서 위치의 값으로 바꿉니다.
- `]` : `MEM` 커서 위치의 값을 프로브에 저장된 값으로 바꿉니다.
- `_` : `MEM` 커서의 X 위치를 프로브에 저장된 값으로 바꿉니다.
- `|` : `MEM` 커서의 Y 위치를 프로브에 저장된 값으로 바꿉니다.
## 5.2. 이동
### 5.2.1. `READ` 포인터 이동
- `READ` 포인터의 이동은 이동 간격과 방향으로 정의되며, 이는 프로브 자체의 이동과 같습니다.
- `>` : `READ` 포인터의 이동 간격을 1 증가시킵니다.
- `<` : `READ` 포인터의 이동 간격을 1 감소시킵니다. 이동 간격이 0이 되면 프로그램은 정지합니다.
- `R` : `READ` 포인터의 이동 방향을 시계 방향으로 90도 돌립니다.
- `L` : `READ` 포인터의 이동 방향을 반시계 방향으로 90도 돌립니다.
### 5.2.2. `WRITE` 포인터 이동
- `→`, `←`, `↑`, `↓` : `WRITE` 포인터의 `READ` 포인터에 대한 상대적 위치를 1칸씩 이동합니다.
### 5.2.3. `MEM` 커서 이동
- `△`, `▽`, `◁`, `▷` : `MEM` 커서를 1칸씩 이동합니다.
- `▲`, `▼`, `◀`, `▶` : `MEM` 커서를 프로브의 이동 간격만큼 이동합니다.
## 5.3. 비휘발성 커맨드
- 이하의 명령들은 다른 비휘발성 커맨드를 `READ` 포인터가 읽어들일 때까지 계속 수행됩니다.
- `S` : 프로브에 저장된 값을 `WRITE` 포인터 위치의 값으로 바꿉니다.
- `s` : `WRITE` 포인터 위치의 값을 프로브에 저장된 값으로 바꿉니다.
- `P` : 콘솔에 `WRITE` 포인터 위치의 값(문자)을 출력합니다.
- `I` : `WRITE` 포인터 위치에 유저 입력을 한 번에 한 글자씩 저장합니다.
- `X` : `S`, `s`, `P`, `I` 동작을 중지합니다.
## 5.4. 주석
- `!` : `READ` 포인터가 이 명령을 읽어들일 경우 `READ` 포인터는 다시 `!`를 읽어들일 때까지 모든 명령을 무시합니다.

# 6. 예제 코드
## 6.1. Hello world!
```
↓P...........<
.HELLO WORLD!.
```
## 6.2. Repeatedly adding 1 until 9
```
①.>R..<.[..↓..+....↑←←R
...↓......n\..0L]XS←←▷R
...↓.......9..>↔L→→→→◁R
...R↓Xs↑.X.PXSP.....↑↑R
..............L.<→→→→↓R
........<X..........P.R
..........n\!dehsiniF..
```
## 6.3. 1 to 99
```
R......................................................................
/ ! MEMORY SPACE FOR FIRST DIGIT   ! ..................................
0 ! MEMORY SPACE FOR SECOND DIGIT  ! ..................................
① ! MEMORY SPACE FOR INTEGER CONST ! ..................................
......................................................! END ! <........
............<.................................................<........
L▽→[........↕9.................................................9.......
....R─────▽→←△─────────────────────────────────────────R.R↑──>L↔<─R....
....│.......................! CALCULATION SPACE !.0....│.│........↓....
....│...! LOADING VARIABLE       !..L────────────Xs[▽↑─R.│........│....
....│...! ADDING OPERATION       !..L↑▽▽[─────────+───△R.│........│....
....│...! SAVING VARIABLE TO MEM !..L───────────]XS──↑△R.│........│....
....│...! RETURNING WRITE POS    !..L──────────────↓↓↓───R........│....
....│.............................................................│....
....│.....0.! RESERVED SPACE !....................................│....
....R↓↓─────△△─────────────────L.! RETURNING MEM POS !............│....
....R↑↑───SX▽▽]────────────────L.! RESETTING DIGIT   !............│....
....│.............................................................│....
....←.R←────────────────────────────────────────────────────────R │....
....├↔8...........................! CALCULATION SPACE !.n\0.....│ │....
....→→..! LOADING VARIABLE       !..L────────────────────Xs[▽▽↑─R │....
....││..! ADDING OPERATION       !..L↑▽[──────────────────+─────R │....
....││..! SAVING VARIABLE TO MEM !..L───────────────────]XS───↑△R │....
....││..! LOADING VARIABLE       !..L↑△[──────────────────sX────R │....
....││..! PRINTING VARIABLE      !..L────────────────────XP───↑─R │....
....││..! LOADING VARIABLE       !..L↑▽[──────────────────sX────R │....
....││..! PRINTING VARIABLE      !..L──────────────────X──P───↑─R │....
....││..! RETURNING WRITE POS    !..L↓△△──────────────────↓↓↓↓↓↓R │....
....││..........................................................│.│....
....│R──────────────────────────────────────────────────←─┬──→──R │....
....│.....................................................↕9─→────R....
....R───────────────────────────────────────────────────←─┘............
.......................................................................
```
